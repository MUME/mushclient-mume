<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- This Source Code Form is subject to the terms of the Mozilla Public -->
<!-- License, v. 2.0. If a copy of the MPL was not distributed with this -->
<!-- file, You can obtain one at http://mozilla.org/MPL/2.0/. -->

<!-- Saved on Friday, February 24, 2012, 3:27 AM -->
<!-- MuClient version 4.81 -->

<!-- Plugin "mume_secrets_database" generated by Plugin Wizard -->

<muclient>
<plugin
   name="mume_secrets_database"
   author="Nick Stockton"
   id="dcd3538b52a2e4a5c5af9003"
   language="Lua"
   purpose="provides access to a database of hidden exits in mume."
   date_written="2012-02-24 03:23:31"
   requires="4.70"
   version="1.0"
   >

</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Aliases  -->

<aliases>
  <alias
   name="print_room_name"
   match="roomname"
   enabled="y"
   group="mume_secrets_database"
   send_to="12"
   sequence="100"
  >
  <send>getRoomName()</send>
  </alias>
  <alias
   name="Open_all_secrets"
   match="ddo"
   enabled="y"
   group="mume_secrets_database"
   send_to="12"
   sequence="100"
  >
  <send>actionAll("open")</send>
  </alias>
  <alias
   name="add_room"
   match="^dadd(?P&lt;door&gt; \w+)?(?P&lt;direction&gt; \w+)?$"
   enabled="y"
   group="mume_secrets_database"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>add("%&lt;door&gt;", "%&lt;direction&gt;")</send>
  </alias>
  <alias
   name="delete_secrets"
   match="^ddel(?P&lt;door&gt; \w+)?(?P&lt;direction&gt; \w+)?$"
   enabled="y"
   group="mume_secrets_database"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>delete("%&lt;door&gt;", "%&lt;direction&gt;")</send>
  </alias>
  <alias
   name="display_room_info"
   match="^dinfo(?P&lt;text&gt; .+)?$"
   enabled="y"
   group="mume_secrets_database"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>info("%&lt;text&gt;")</send>
  </alias>
</aliases>

<!--  Script  -->


<script>
<![CDATA[
require("mystdlib")
json = require("dkjson")

TTS = "925cdd0331023d9f0b8f05a7"
XML_PARSER = "74834d3734b2c8a3a9da4d18"

DATABASE_FILE = string.format("%sdatabases\\secret_exits.json", GetInfo(67))
SAMPLE_DATABASE_FILE = string.format("%sdatabases\\secret_exits.json.sample", GetInfo(67))

VALID_DIRECTIONS = {"north", "east", "south", "west", "up", "down"}
VALID_DIRECTIONS_INDEX = {}
for index, direction in ipairs(VALID_DIRECTIONS) do
	VALID_DIRECTIONS_INDEX[direction] = index
end

room_name = ""

if os.isFile(DATABASE_FILE) then
	fileObj = io.open(DATABASE_FILE, "rb")
	rooms = json.decode(fileObj:read("*all"), 1, nil)
	fileObj:close()
elseif os.isFile(SAMPLE_DATABASE_FILE) then
	fileObj = io.open(SAMPLE_DATABASE_FILE, "rb")
	rooms = json.decode(fileObj:read("*all"), 1, nil)
	fileObj:close()
else
	rooms = {}
end

function save()
	local orderedKeys = {}
	for key, value in pairs(rooms) do
		table.insert(orderedKeys, key)
	end
	table.sort(orderedKeys)
	local fileObj = io.open(DATABASE_FILE, "wb")
	fileObj:write(json.encode(rooms, {indent=true, level=0, keyorder=orderedKeys}))
	fileObj:close()
end

function getRoomName()
	if room_name == "" then
		CallPlugin(TTS, "say", "Room name undefined!", true)
	else
		CallPlugin(TTS, "say", room_name, true)
	end
end

function OnPluginBroadcast (msg, id, name, text)
	if id == XML_PARSER and name == "mume_XML_PARSER" and msg == 1 then
		local return_code, name = CallPlugin(XML_PARSER, "get", "name")
		room_name = name ~= "You just see a dense fog around you..." and name ~= "It is pitch black..." and name:lower() or ""
	end
end

function directionsSortFunction(first, second)
	-- function to be passed as second argument to table.sort
	-- sort by door if directions are the same, or by direction if not.
	local validDirectionsIndex = VALID_DIRECTIONS_INDEX
	local firstDoor, firstDirection = first[1], first[2]
	local secondDoor, secondDirection = second[1], second[2]
	if firstDirection == secondDirection then
		local sortedDoors = {firstDoor, secondDoor}
		table.sort(sortedDoors)
		return sortedDoors[1] == firstDoor
	else
		return validDirectionsIndex[firstDirection] < validDirectionsIndex[secondDirection]
	end
end

function info(searchString)
	searchString = string.strip(searchString:lower())
	local results = {}
	if searchString ~= "" then
		for name, room in pairs(rooms) do
			if string.match(name, searchString) then
				table.insert(results, name)
			end
		end
	elseif room_name ~= "" and rooms[room_name] then
		table.insert(results, room_name)
	else
		return Note("Error!  Room undefined.")
	end
	if not next(results) then
		return Note(string.format("There aren't any rooms named '%s' in the database.", searchString))
	end
	table.sort(results)
	for resultIndex, name in ipairs(results) do
		local exits = {}
		for exitIndex, exitTbl in ipairs(rooms[name]) do
			local door, direction = unpack(exitTbl)
			if string.strip(direction) ~= "" then
				table.insert(exits, string.format("%s (%s)", direction, door))
			else
				table.insert(exits, string.format("(%s)", door))
			end
		end
		Note(string.format("%s: %s", name, table.concat(exits, ", ")))
	end
end

function actionAll(action)
	local action = string.strip(action)
	if room_name == "" then
		return Note("Error!  Current room undefined.")
	elseif not rooms[room_name] then
		return Note(string.format("There aren't any rooms named '%s' in the database.", room_name))
	elseif action == "" then
		return Note("Error! You must specify an action to perform.")
	end
	for exitIndex, exitTbl in ipairs(rooms[room_name]) do
		local door, direction = unpack(exitTbl)
		if string.strip(direction) ~= "" then
			Send(string.format("%s %s %s", action, door, direction))
		else
			Send(string.format("%s %s", action, door))
		end
	end
end

function add(newDoor, newDirection)
	local validDirections = VALID_DIRECTIONS
	local validDirectionsIndex = VALID_DIRECTIONS_INDEX
	local newDoor = string.strip(newDoor:lower())
	local newDirection = string.strip(newDirection:lower())
	for index, direction in ipairs(validDirections) do
		if newDirection ~= "" and string.startswith(direction, newDirection) then
			newDirection = direction
			break
		end
	end
	if room_name == "" then
		return Note("Error!  Current room undefined.")
	elseif newDoor == "" or newDirection == "" or not validDirectionsIndex[newDirection] then
		return Note(string.format("Syntax: dadd [door] [%s]", table.concat(validDirections, "|")))
	elseif not rooms[room_name] then
		rooms[room_name] = {}
	end
	Note(string.format("adding the door '%s' located '%s' to '%s'.", newDoor, newDirection, room_name))
	table.insert(rooms[room_name], {newDoor, newDirection})
	rooms[room_name] = table.uniqueItems(rooms[room_name])
	table.sort(rooms[room_name], directionsSortFunction)
	save()
end

function delete(delDoor, delDirection)
	local validDirections = VALID_DIRECTIONS
	local validDirectionsIndex = VALID_DIRECTIONS_INDEX
	local delDoor = string.strip(delDoor:lower())
	local delDirection = string.strip(delDirection:lower())
	for index, direction in ipairs(validDirections) do
		if delDirection ~= "" and string.startswith(direction, delDirection) then
			delDirection = direction
			break
		end
	end
	if delDirection ~= "" and string.startswith("all", delDirection) then
		delDirection = "all"
	end
	if room_name == "" then
		return Note("Error!  Room is undefined.")
	elseif not rooms[room_name] then
		return Note("Error! The current room isn't in the database.")
	elseif delDoor == "" or delDirection == "" or (delDirection ~= "all" and not validDirectionsIndex[delDirection]) then
		return Note(string.format("Syntax: ddel [door|all] [%s|all]", table.concat(validDirections, "|")))
	elseif delDoor ~= "all" and delDirection ~= "all" then
		local delExitIndex = nil
		for exitIndex, exitTbl in ipairs(rooms[room_name]) do
			local door, direction = unpack(exitTbl)
			if door == delDoor and direction == delDirection then
				delExitIndex = exitIndex
				break
			end
		end
		if delExitIndex then
			Note(string.format("Deleting '%s' located '%s' from '%s'.", delDoor, delDirection, room_name))
			table.remove(rooms[room_name], delExitIndex)
		else
			return Note(string.format("'%s' does not have any exits to the '%s' with the name '%s'.", room_name, delDirection, delDoor))
		end
	elseif delDirection ~= "all" then
		-- Check to see if the current room has any secrets in the given direction.
		local hasDeletableExits = false
		local keepExits = {}
		for exitIndex, exitTbl in ipairs(rooms[room_name]) do
			local door, direction = unpack(exitTbl)
			if direction ~= delDirection then
				table.insert(keepExits, exitTbl)
			else
				hasDeletableExits = true
			end
		end
		if hasDeletableExits then
			Note(string.format("Deleting all exits '%s' from '%s'.", delDirection, room_name))
			rooms[room_name] = keepExits
		else
			return Note(string.format("'%s' does not have any exits to the '%s'.", room_name, delDirection))
		end
	elseif delDoor ~= "all" then
		-- Check to see if the current room has any secret doors with the given name.
		local hasDeletableExits = false
		local keepExits = {}
		for exitIndex, exitTbl in ipairs(rooms[room_name]) do
			local door, direction = unpack(exitTbl)
			if door ~= delDoor then
				table.insert(keepExits, exitTbl)
			else
				hasDeletableExits = true
			end
		end
		if hasDeletableExits then
			Note(string.format("Deleting all secret doors with the name '%s' from '%s'.", delDoor, room_name))
			rooms[room_name] = keepExits
		else
			return Note(string.format("'%s' does not have any secret doors called '%s'.", room_name, delDoor))
		end
	end
	if delDoor == "all" and delDirection == "all" or not next(rooms[room_name]) then
		Note(string.format("Deleting the room '%s' from the database.", room_name))
		rooms[room_name] = nil
	end
	save()
end

]]>
</script>


</muclient>
