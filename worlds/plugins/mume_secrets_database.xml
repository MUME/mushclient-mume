<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- This Source Code Form is subject to the terms of the Mozilla Public -->
<!-- License, v. 2.0. If a copy of the MPL was not distributed with this -->
<!-- file, You can obtain one at http://mozilla.org/MPL/2.0/. -->

<!-- Saved on Friday, February 24, 2012, 3:27 AM -->
<!-- MuClient version 4.81 -->

<!-- Plugin "mume_secrets_database" generated by Plugin Wizard -->

<muclient>
<plugin
   name="mume_secrets_database"
   author="Nick Stockton"
   id="dcd3538b52a2e4a5c5af9003"
   language="Lua"
   purpose="provides access to a database of hidden exits in mume."
   date_written="2012-02-24 03:23:31"
   requires="4.70"
   version="1.0"
   >

</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Aliases  -->

<aliases>
  <alias
   name="Open_all_secrets"
   match="ddo"
   enabled="y"
   group="mume_secrets_database"
   send_to="12"
   sequence="100"
  >
  <send>action_all("open")</send>
  </alias>
  <alias
   name="add_room"
   match="^dadd(?:\s+(?P&lt;door&gt;\w+))?(?:\s+(?P&lt;direction&gt;\w+))?$"
   enabled="y"
   group="mume_secrets_database"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>add("%&lt;door&gt;", "%&lt;direction&gt;")</send>
  </alias>
  <alias
   name="delete_secrets"
   match="^ddel(?:\s+(?P&lt;door&gt;\w+))?(?:\s+(?P&lt;direction&gt;\w+))?$"
   enabled="y"
   group="mume_secrets_database"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>delete("%&lt;door&gt;", "%&lt;direction&gt;")</send>
  </alias>
  <alias
   name="display_room_info"
   match="^dinfo(?:\s+(?P&lt;text&gt;.+))?$"
   enabled="y"
   group="mume_secrets_database"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>info("%&lt;text&gt;")</send>
  </alias>
</aliases>

<!--  Script  -->


<script>
<![CDATA[
require("mystdlib")
json = require("dkjson")
-- For compatibility with Lua >= 5.2.
unpack = rawget(table, "unpack") or unpack

TTS = "925cdd0331023d9f0b8f05a7"
XML_PARSER = "74834d3734b2c8a3a9da4d18"
BROADCAST_NAME = 4
DATABASE_FILE = GetInfo(67) .. "databases\\secret_exits.json"
SAMPLE_DATABASE_FILE = DATABASE_FILE .. ".sample"
ORDERED_DIRECTIONS = {"north", "east", "south", "west", "up", "down"}
DIRECTIONS = {}
for index, direction in ipairs(ORDERED_DIRECTIONS) do
	DIRECTIONS[direction] = index
end

room_name = ""

if os.isFile(DATABASE_FILE) then
	file_obj = io.open(DATABASE_FILE, "rb")
	rooms = json.decode(file_obj:read("*all"), 1, nil)
	file_obj:close()
elseif os.isFile(SAMPLE_DATABASE_FILE) then
	file_obj = io.open(SAMPLE_DATABASE_FILE, "rb")
	rooms = json.decode(file_obj:read("*all"), 1, nil)
	file_obj:close()
else
	rooms = {}
end

function save()
	local ordered_keys = {}
	for key, _ in pairs(rooms) do
		table.insert(ordered_keys, key)
	end
	table.sort(ordered_keys)
	local file_obj = io.open(DATABASE_FILE, "wb")
	file_obj:write(json.encode(rooms, {indent=true, level=0, keyorder=ordered_keys}))
	file_obj:close()
end

function directions_sorter(first, second)
	-- function to be passed as second argument to table.sort.
	-- Sort by direction, or by door if directions are the same.
	local first_door, first_direction = unpack(first)
	local second_door, second_direction = unpack(second)
	if first_direction == second_direction then
		local sorted_doors = {first_door, second_door}
		table.sort(sorted_doors)
		return sorted_doors[1] == first_door
	else
		return DIRECTIONS[first_direction] < DIRECTIONS[second_direction]
	end
end

function info(text)
	text = string.strip(text:lower())
	local results = {}
	if text ~= "" then
		for name, _ in pairs(rooms) do
			if string.findpos(name, text) then
				table.insert(results, name)
			end
		end
	elseif room_name ~= "" and rooms[room_name] then
		table.insert(results, room_name)
	else
		return Note("Error!  Room undefined.")
	end
	if not next(results) then
		return Note("There aren't any rooms named '", text, "' in the database.")
	end
	table.sort(results)
	for _, name in ipairs(results) do
		local exits = {}
		for _, exit in ipairs(rooms[name]) do
			local door, direction = unpack(exit)
			if string.strip(direction) ~= "" then
				table.insert(exits, string.format("%s (%s)", direction, door))
			else
				table.insert(exits, string.format("(%s)", door))
			end
		end
		Note(string.format("%s: %s", name, table.concat(exits, ", ")))
	end
end

function action_all(action)
	local action = string.strip(action)
	if room_name == "" then
		return Note("Error!  Current room undefined.")
	elseif not rooms[room_name] then
		return Note(string.format("There aren't any rooms named '%s' in the database.", room_name))
	elseif action == "" then
		return Note("Error! You must specify an action to perform.")
	end
	for _, exit in ipairs(rooms[room_name]) do
		local door, direction = unpack(exit)
		if string.strip(direction) ~= "" then
			Send(string.format("%s %s %s", action, door, direction))
		else
			Send(string.format("%s %s", action, door))
		end
	end
end

function add(door, direction)
	local door = string.strip(door:lower())
	local direction = string.strip(direction:lower())
	for _, dir in ipairs(ORDERED_DIRECTIONS) do
		if direction ~= "" and string.startswith(dir, direction) then
			direction = dir
			break
		end
	end
	if room_name == "" then
		return Note("Error!  Current room undefined.")
	elseif door == "" or direction == "" or not DIRECTIONS[direction] then
		return Note(string.format("Syntax: dadd [door] [%s]", table.concat(ORDERED_DIRECTIONS, "|")))
	elseif not rooms[room_name] then
		rooms[room_name] = {}
	end
	Note(string.format("adding the door '%s' located '%s' to '%s'.", door, direction, room_name))
	table.insert(rooms[room_name], {door, direction})
	rooms[room_name] = table.uniqueItems(rooms[room_name])
	table.sort(rooms[room_name], directions_sorter)
	save()
end

function delete(del_door, del_direction)
	local del_door = string.strip(del_door:lower())
	local del_direction = string.strip(del_direction:lower())
	for _, dir in ipairs(ORDERED_DIRECTIONS) do
		if del_direction ~= "" and string.startswith(dir, del_direction) then
			del_direction = dir
			break
		end
	end
	if del_direction ~= "" and string.startswith("all", del_direction) then
		del_direction = "all"
	end
	if room_name == "" then
		return Note("Error!  Room is undefined.")
	elseif not rooms[room_name] then
		return Note("Error! The current room isn't in the database.")
	elseif del_door == "" or del_direction == "" or (del_direction ~= "all" and not DIRECTIONS[del_direction]) then
		return Note(string.format("Syntax: ddel [door|all] [%s|all]", table.concat(ORDERED_DIRECTIONS, "|")))
	elseif del_door ~= "all" and del_direction ~= "all" then
		local del_index = 0
		for index, exit in ipairs(rooms[room_name]) do
			local door, direction = unpack(exit)
			if door == del_door and direction == del_direction then
				del_index = index
				break
			end
		end
		if del_index > 0 then
			Note(string.format("Deleting '%s' located '%s' from '%s'.", del_door, del_direction, room_name))
			table.remove(rooms[room_name], del_index)
		else
			return Note(string.format("'%s' does not have any exits to the '%s' with the name '%s'.", room_name, del_direction, del_door))
		end
	elseif del_direction ~= "all" then
		-- Check to see if the current room has any secrets in the given direction.
		local dir_exists = false
		local keep_exits = {}
		for _, exit in ipairs(rooms[room_name]) do
			local door, direction = unpack(exit)
			if direction ~= del_direction then
				table.insert(keep_exits, exit)
			else
				dir_exists = true
			end
		end
		if dir_exists then
			Note(string.format("Deleting all exits '%s' from '%s'.", del_direction, room_name))
			rooms[room_name] = keep_exits
		else
			return Note(string.format("'%s' does not have any exits to the '%s'.", room_name, del_direction))
		end
	elseif del_door ~= "all" then
		-- Check to see if the current room has any secret doors with the given name.
		local door_exists = false
		local keep_exits = {}
		for _, exit in ipairs(rooms[room_name]) do
			local door, direction = unpack(exit)
			if door ~= del_door then
				table.insert(keep_exits, exit)
			else
				door_exists = true
			end
		end
		if door_exists then
			Note(string.format("Deleting all secret doors with the name '%s' from '%s'.", del_door, room_name))
			rooms[room_name] = keep_exits
		else
			return Note(string.format("'%s' does not have any secret doors called '%s'.", room_name, del_door))
		end
	end
	if del_door == "all" and del_direction == "all" or not next(rooms[room_name]) then
		Note(string.format("Deleting the room '%s' from the database.", room_name))
		rooms[room_name] = nil
	end
	save()
end

function OnPluginBroadcast (msg, id, name, text)
	if id == XML_PARSER and name == "mume_xml_parser" and msg == BROADCAST_NAME then
		room_name = string.strip(text:lower())
	end
end

]]>
</script>


</muclient>
