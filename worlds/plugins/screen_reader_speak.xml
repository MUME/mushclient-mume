<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- This Source Code Form is subject to the terms of the Mozilla Public -->
<!-- License, v. 2.0. If a copy of the MPL was not distributed with this -->
<!-- file, You can obtain one at http://mozilla.org/MPL/2.0/. -->

<!-- Saved on Wednesday, May 06, 2015, 6:12 PM -->
<!-- MuClient version 4.60 -->

<!-- Plugin "screen_reader_speak" generated by Plugin Wizard -->

<muclient>
<plugin
   name="screen_reader_speak"
   author="Nick Stockton"
   id="925cdd0331023d9f0b8f05a7"
   language="Lua"
   purpose="Automatically speak using screen reader APIs."
   date_written="2015-05-06 18:12:34"
   requires="4.60"
   version="1.0"
   >

</plugin>
<aliases>
  <alias
   script="tts_toggle"
   match="tts"
   enabled="y"
   group="screen_reader_speak"
   omit_from_command_history="y"
   omit_from_log="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>
</aliases>


<!--  Get our standard constants -->

<include name="constants.lua"/>
<script>
<![CDATA[
local luacom = require "luacom"
local ffi = require "ffi"

ffi.cdef[[
	typedef void *PVOID;
	typedef PVOID HANDLE;
	typedef HANDLE HWND, HINSTANCE;
	typedef unsigned long DWORD;
	typedef unsigned int UINT;
	typedef char CHAR;
	typedef wchar_t WCHAR;
	typedef CHAR *PSTR, *LPSTR;
	typedef const CHAR *PCSTR, *LPCSTR, *LPCCH, *PCCH;
	typedef WCHAR *PWSTR, *LPWSTR;
	typedef const WCHAR *PCWSTR, *LPCWSTR;
	int MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
	HWND FindWindowA(LPCSTR lpClassName, LPCSTR lpWindowName);
	size_t wcslen(const wchar_t *str);
	void __stdcall DolAccess_Command(const wchar_t*, unsigned int, unsigned int);
	void __stdcall DolAccess_Action(unsigned int);
	int __stdcall DolAccess_GetSystem(void);
	void __stdcall nvdaController_speakText(const wchar_t*);
	void __stdcall nvdaController_cancelSpeech(void);
	int __stdcall nvdaController_testIfRunning(void);
	void __stdcall SA_SayW(const wchar_t*);
	void __stdcall SA_StopAudio(void);
	int __stdcall SA_IsRunning(void);
]]

local DOLACCESS_NONE = 0
local DOLACCESS_SPEAK = 1
local DOLACCESS_MUTE = 141

local CP_1252 = 1252  -- ANSI Latin-1.
local CP_ASCII = 20127
local CP_LATIN1 = 28591  -- ISO 8859-1
local CP_UTF8 = 65001

local ERROR_NO_UNICODE_TRANSLATION = 1113

local IS_32_BIT = ffi.abi("32bit")

local tts_enabled = true

local ffiC = ffi.C
local ffiNew = ffi.new
local NULL = ffiNew("void*")
local SIZE_OF_WCHAR = ffi.sizeof("wchar_t")

local nvda_api = IS_32_BIT and ffi.load("screen_reader_dlls/nvdaControllerClient32.dll") or ffi.load("screen_reader_dlls/nvdaControllerClient64.dll")
local sa_api = IS_32_BIT and ffi.load("screen_reader_dlls/SAAPI32.dll") or ffi.load("screen_reader_dlls/SAAPI64.dll")
local dolphin_api = IS_32_BIT and ffi.load("screen_reader_dlls/dolapi32.dll")

-- If you need the numeric value of a window handle, casting it to intptr_t and passing the result to tonumber should work.
-- tonumber(ffi.cast("intptr_t", handle))

local function pointer(ptr)
	-- When used to wrap other functions that return pointers, this function will return nil if the return value is a NULL pointer, or the pointer otherwise.
	-- Because a NULL pointer is *not* automatically cast to nil or false, its boolean value is always true.
	return ptr ~= NULL and ptr or nil
end

local function dolphin_running()
	return dolphin_api and dolphin_api.DolAccess_GetSystem() ~= DOLACCESS_NONE
end

local function dolphin_say(text, interrupt)
	if interrupt and interrupt ~= 0 then
		dolphin_api.DolAccess_Action(DOLACCESS_MUTE)
	end
	local length = (ffiC.wcslen(text) + 1) * SIZE_OF_WCHAR
	dolphin_api.DolAccess_Command(text, length, DOLACCESS_SPEAK)
end

local function dolphin_silence()
	dolphin_api.DolAccess_Action(DOLACCESS_MUTE)
end

local function jfw_running()
	return pointer(ffiC.FindWindowA("JFWUI2", nil)) and true or false
end

local function jfw_say(text, interrupt)
	local jfw_api = assert (luacom.CreateObject ("FreedomSci.JawsApi"), "cannot open Jaws COM object")
	if interrupt and interrupt ~= 0 then
		jfw_api:SayString(text, 1)
	else
		jfw_api:SayString(text, 0)
	end
end

local function jfw_silence()
	local jfw_api = assert (luacom.CreateObject ("FreedomSci.JawsApi"), "cannot open Jaws COM object")
	jfw_api:StopSpeech()
end

local function nvda_running()
	return nvda_api.nvdaController_testIfRunning() == 0
end

local function nvda_say(text, interrupt)
	if interrupt and interrupt ~= 0 then
		nvda_api.nvdaController_cancelSpeech()
	end
	nvda_api.nvdaController_speakText(text)
end

local function nvda_silence()
	nvda_api.nvdaController_cancelSpeech()
end

local function sa_running()
	return sa_api.SA_IsRunning() ~= 0
end

local function sa_say(text, interrupt)
	if interrupt and interrupt ~= 0 then
		sa_api.SA_StopAudio()
	end
	sa_api.SA_SayW(text)
end

local function sa_silence()
	sa_api.SA_StopAudio()
end

local function we_running()
	return pointer(ffiC.FindWindowA("GWMExternalControl", "External Control")) and true or false
end

local function we_say(text, interrupt)
	local we_api = assert (luacom.CreateObject ("GWSpeak.Speak"), "cannot open Win-Eyes COM object")
	if interrupt and interrupt ~= 0 then
		we_api:Silence()
	end
	we_api:SpeakString(text)
end

local function we_silence()
	local we_api = assert (luacom.CreateObject ("GWSpeak.Speak"), "cannot open Win-Eyes COM object")
	we_api:Silence()
end

function say(text, interrupt)
	if not text or Trim(text) == "" then
		return
	end
	local codepage = CP_UTF8
	local length = utils.utf8valid(text)
	if not length then
		codepage = CP_LATIN1
		length = ffiC.MultiByteToWideChar(codepage, 0, text, #text, nil, 0)
	end
	local widestr = ffiNew("wchar_t[?]", length + 1)
	local chars_written = ffiC.MultiByteToWideChar(codepage, 0, text, #text, widestr, length)
	if ffi.errno(0) == ERROR_NO_UNICODE_TRANSLATION then
		-- User should hopefully never see this.
		return Note("Error in screen reader speak plugin: no unicode translation.")
	end
	-- Null terminate the data.
	widestr[chars_written] = 0
	if nvda_running() then
		nvda_say(widestr, interrupt)
	elseif sa_running() then
		sa_say(widestr, interrupt)
	elseif dolphin_running() then
		dolphin_say(widestr, interrupt)
	elseif we_running() then
		we_say(text, interrupt)
	elseif jfw_running() then
		jfw_say(text, interrupt)
	end
end

function silence()
	if nvda_running() then
		nvda_silence()
	elseif sa_running() then
		sa_silence()
	elseif dolphin_running() then
		dolphin_silence()
	elseif we_running() then
		we_silence()
	elseif jfw_running() then
		jfw_silence()
	end
end

function OnPluginScreendraw(line_type, log, line)
	if tts_enabled and line_type < 2 then
		say(line)
	end
end

function tts_toggle(name, line, wildcards)
	tts_enabled = not tts_enabled
	say(string.format("Speech %s.", tts_enabled and "on" or "off"), true)
end

function OnPluginTabComplete(word)
	if tts_enabled then
		say(word)
	end
end

]]>            
 </script> 
</muclient>
