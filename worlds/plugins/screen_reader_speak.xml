<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- This Source Code Form is subject to the terms of the Mozilla Public -->
<!-- License, v. 2.0. If a copy of the MPL was not distributed with this -->
<!-- file, You can obtain one at http://mozilla.org/MPL/2.0/. -->

<!-- Saved on Wednesday, May 06, 2015, 6:12 PM -->
<!-- MuClient version 4.60 -->

<!-- Plugin "screen_reader_speak" generated by Plugin Wizard -->

<muclient>
<plugin
   name="screen_reader_speak"
   author="Nick Stockton"
   id="925cdd0331023d9f0b8f05a7"
   language="Lua"
   purpose="Automatically speak using screen reader APIs."
   date_written="2015-05-06 18:12:34"
   requires="4.60"
   version="1.0"
   >

</plugin>
<aliases>
  <alias
   script="tts_toggle"
   match="tts"
   enabled="y"
   group="screen_reader_speak"
   omit_from_command_history="y"
   omit_from_log="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>
</aliases>


<!--  Get our standard constants -->

<include name="constants.lua"/>
<script>
<![CDATA[
local luacom = require "luacom"
local ffi = require "ffi"

ffi.cdef[[
	typedef void *PVOID;
	typedef PVOID HANDLE;
	typedef HANDLE HWND, HINSTANCE;
	typedef unsigned long DWORD;
	typedef unsigned int UINT;
	typedef char CHAR;
	typedef wchar_t WCHAR;
	typedef CHAR *PSTR, *LPSTR;
	typedef const CHAR *PCSTR, *LPCSTR, *LPCCH, *PCCH;
	typedef WCHAR *PWSTR, *LPWSTR;
	typedef const WCHAR *PCWSTR, *LPCWSTR;
	typedef long BOOL;
	typedef BOOL *LPBOOL;
	int MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
	int WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
	HWND FindWindowA(LPCSTR lpClassName, LPCSTR lpWindowName);
	size_t wcslen(const wchar_t *str);
	void __stdcall nvdaController_speakText(const wchar_t*);
	void __stdcall nvdaController_cancelSpeech(void);
	int __stdcall nvdaController_testIfRunning(void);
	void __stdcall SA_SayW(const wchar_t*);
	void __stdcall SA_StopAudio(void);
	int __stdcall SA_IsRunning(void);
]]

local CP_1252 = 1252  -- Windows ANSI.
local CP_ACP = 0  -- ANSI Code Page, the system locale as set in the Windows control panel, or in "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Nls\CodePage\ACP".
local CP_ASCII = 20127  -- U.S ASCII.
local CP_LATIN1 = 28591  -- ISO 8859-1.
local CP_UTF8 = 65001

local ERROR_NO_UNICODE_TRANSLATION = 1113

local IS_32_BIT = ffi.abi("32bit")

local tts_enabled = true

local utf8valid = utils.utf8valid
local ffiC = ffi.C
local ffiNew = ffi.new
local NULL = ffiNew("void*")
local SIZE_OF_WCHAR = ffi.sizeof("wchar_t")

local nvda_api = IS_32_BIT and ffi.load("screen_reader_dlls/nvdaControllerClient32.dll") or ffi.load("screen_reader_dlls/nvdaControllerClient64.dll")
local sa_api = IS_32_BIT and ffi.load("screen_reader_dlls/SAAPI32.dll") or ffi.load("screen_reader_dlls/SAAPI64.dll")

-- If you need the numeric value of a window handle, casting it to intptr_t and passing the result to tonumber should work.
-- tonumber(ffi.cast("intptr_t", handle))

local function pointer(ptr)
	-- When used to wrap other functions that return pointers, this function will return nil if the return value is a NULL pointer, or the pointer otherwise.
	-- Because a NULL pointer is *not* automatically cast to nil or false, its boolean value is always true.
	return ptr ~= NULL and ptr or nil
end

local function bytes(wstr, codepage)
	local length = ffi.C.WideCharToMultiByte(codepage, 0, wstr, -1, nil, 0, nil, false)
	local data = ffi.new("char[?]", length)
	ffi.C.WideCharToMultiByte(codepage, 0, wstr, -1, data, length, nil, false)
	return ffi.string(data)
end

local function unicode(data, codepage)
	local length = ffi.C.MultiByteToWideChar(codepage, 0, data, -1, nil, 0)
	local wstr = ffi.new("wchar_t[?]", length)
	ffi.C.MultiByteToWideChar(codepage, 0, data, #data, wstr, length)
	return wstr
end

local function decode_bytes(data)
	local wstr
	local length, err_col = utf8valid(data)
	if not err_col then
		wstr = unicode(data, CP_UTF8)
	else
		-- Not UTF-8, try Latin-1.
		wstr = unicode(data, CP_LATIN1)
	end
	if ffi.errno(0) == ERROR_NO_UNICODE_TRANSLATION then
		-- User should hopefully never see this.
		Note("Error in screen reader speak plugin: no unicode translation.")
	end
	return wstr
end

local function jfw_running()
	return pointer(ffiC.FindWindowA("JFWUI2", nil)) and true or false
end

local function jfw_say(text, interrupt)
	local jfw_api = assert (luacom.CreateObject ("FreedomSci.JawsApi"), "cannot open Jaws COM object")
	jfw_api:SayString(text, interrupt and interrupt ~= 0 and 1 or 0)
end

local function jfw_silence()
	local jfw_api = assert (luacom.CreateObject ("FreedomSci.JawsApi"), "cannot open Jaws COM object")
	jfw_api:StopSpeech()
end

local function nvda_running()
	return nvda_api.nvdaController_testIfRunning() == 0
end

local function nvda_say(text, interrupt)
	if interrupt and interrupt ~= 0 then
		nvda_api.nvdaController_cancelSpeech()
	end
	nvda_api.nvdaController_speakText(decode_bytes(text))
end

local function nvda_silence()
	nvda_api.nvdaController_cancelSpeech()
end

local function sa_running()
	return sa_api.SA_IsRunning() ~= 0
end

local function sa_say(text, interrupt)
	if interrupt and interrupt ~= 0 then
		sa_api.SA_StopAudio()
	end
	sa_api.SA_SayW(decode_bytes(text))
end

local function sa_silence()
	sa_api.SA_StopAudio()
end

function say(text, interrupt)
	if not text or Trim(text) == "" then
		return
	end
	if nvda_running() then
		nvda_say(text, interrupt)
	elseif sa_running() then
		sa_say(text, interrupt)
	elseif jfw_running() then
		jfw_say(text, interrupt)
	end
end

function silence()
	if nvda_running() then
		nvda_silence()
	elseif sa_running() then
		sa_silence()
	elseif jfw_running() then
		jfw_silence()
	end
end

function OnPluginScreendraw(line_type, log, line)
	if tts_enabled and line_type < 2 then
		say(line)
	end
end

function tts_toggle(name, line, wildcards)
	tts_enabled = not tts_enabled
	say(string.format("Speech %s.", tts_enabled and "on" or "off"), true)
end

function OnPluginTabComplete(word)
	if tts_enabled then
		say(word)
	end
end

]]>            
 </script> 
</muclient>
