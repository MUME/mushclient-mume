<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Sunday, March 03, 2019, 12:29 PM -->
<!-- MuClient version 5.06 -->

<!-- Plugin "portal_wizard" generated by Plugin Wizard -->

<muclient>
<plugin
   name="mume_portal_wizard"
   author="Elerrina"
   id="8ab101a978791d5d1f0a6f41"
   language="Lua"
   purpose="Making portalling convenient."
   save_state="y"
   date_written="2019-03-03 12:25:46"
   requires="5.06"
   version="2.0"
   >

</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>
<aliases>

<alias
   name="keys"
   match="keys"
   enabled="y"
   expand_variables="y"
   group="portal"
   send_to="12"
   sequence="100"
  >
  <send>
  Note("\\nRecent Captures:\\n----------------")
  for k,v in pairs(temp_keys) do
    Note("[",k,"] ",v.label," - ",key_timer_status(v.time))
	end
  </send>
  </alias>

  <alias
   name="portal"
   match="^port(?:[ ]+(.*))?$"
   enabled="y"
   expand_variables="y"
   regexp="y"
   group="portal"
   send_to="12"
   sequence="100"
  >
  <send>
  if type(%1) == "number" then
    Send("cast \'portal\' up ", keys[%1].key)
  else
    Send("cast \'portal\' up ", keys["%1"].key)
  end
  </send>
  </alias>

  <alias
   name="teleport"
   match="^tele(?:[ ]+(.*))?$"
   enabled="y"
   expand_variables="y"
   regexp="y"
   group="portal"
   send_to="12"
   sequence="100"
  >
  <send>
  if type(%1) == "number" then
    Send("cast \'teleport\' ", keys[%1].key)
  else
    Send("cast \'teleport\' ", keys["%1"].key)
  end
  </send>
  </alias>  
  
  <alias
   name="cache"
   match="^cache(?:[ ]+(?P&lt;args&gt;.*))?$"
   enabled="y"
   expand_variables="y"
   regexp="y"
   group="portal"
   send_to="12"
   sequence="100"
   omit_from_output="n"
  >
  <send>
 debug("string capture: %&lt;args&gt;")
 args = utils.split("%&lt;args&gt;"," ")
 if args[1] == "name" then 
   n = tonumber(args[2])
   name = args[3]
   keys[name]=keys[n]
   table.remove(keys, n)
   Note ("Key [",n,"] renamed to [",name,"]")
   set(keys)
   return
 elseif args[1] == "clear" then
   table.clear(keys)
   set(keys)
   Note("Key cache cleared!")
   return
 elseif args[1] == "remove" then
     table.remove(args, 1)
   for i, v in pairs(args) do
   Note(i,v)
     v = tonumber(v)
	 table.remove(keys, args[v])
	 Note("Key [",v,"] removed.")
   end
   set(keys)
   return
 elseif "%&lt;args&gt;" == "" then
    Note("\\nCached keys:\\n----------------\\n")
    for k, v in pairs(keys) do
	  if type(k) ~= "number" then
	    Note("[",k,"] ",v.label," - ",key_timer_status(v.time))
	  end
	end
	for k, v in ipairs(keys) do
	    Note("[",k,"] ",v.label," - ",key_timer_status(v.time))		
	end
  else
   for i, v in pairs(args) do
     v = tonumber(v)
	 table.insert(keys, temp_keys[v])
	 table.remove(temp_keys, v)
     set(keys)
	 Note("Moved key ["..v.."] to cache!")
   end
   end

  
  </send>
  </alias>
<!--  	for k,v in pairs(keys) do
	  if type(keys[k]) == string then
	  Note("[",k,"] ",v.label," - ",key_timer_status(v.time))
	  end
	end
    for k,v in pairs(keys) do
    Note("[",k,"] ",v.label," - ",key_timer_status(v.time))
	end  -->
  <alias
   name="locate_life"
   match="locl(?:[ ]+(.*))?$"
   enabled="y"
   expand_variables="y"
   group="portal"
   send_to="12"
   sequence="100"
   regexp="y"
  >  
<send>
debug("triggered")
temp_keys = {}
Send("cast 'locate life' %1")
</send>
</alias>
</aliases>
<!--  Triggers  -->

<triggers>
  <trigger
   enabled="y"
   expand_variables="y"
   group="portal"
   keep_evaluating="y"
   match="^(?P&lt;label&gt;.*?)\s*\-\s*(?P&lt;terrain&gt;[A-Z].*?)\s*(?P&lt;distance&gt;[A-Z].*?)\s*key\:\s+'(?P&lt;key&gt;\w+)'$"
   name="capture_keys"
   regexp="y"
   send_to="12"
   sequence="100"
   omit_from_output="y"
  >
  <send>
  debug("%&lt;label&gt;, %&lt;terrain&gt;, %&lt;distance&gt;, %&lt;key&gt;")
  result = {["label"]="%&lt;label&gt;",["terrain"]="%&lt;terrain&gt;",["distance"]="%&lt;distance&gt;",["key"]="%&lt;key&gt;",["time"]=os.time()}
  for k,v in pairs(result) do debug(k,": ", v) end
  table.insert(temp_keys, result)
  Note("[",#temp_keys,"] ",result.label,"\\t - ",result.terrain, "\\t", result.distance, "\\t", "key: '",result.key,"'")
</send>
  </trigger>
  
<!--   <trigger
   enabled="y"
   group="id_capture"
   match="A slender plant grows here, a single cluster of flowers atop its narrow stem."
   omit_from_output="n"
   send_to="12"
   sequence="100"
   multi-line="y"
   regexp="y"
  >   -->
  
</triggers>

<script><![CDATA[

require "tprint"
require("mystdlib")
json = require("dkjson")

DEBUG = "b495c8a7ee3c2a668c6d41ba"
PORT_KEYS_FILE = string.format("%sdatabases\\port_keys.json", GetInfo(67))

keys={}
temp_keys = {}
--player="rossiel"

if os.isFile(PORT_KEYS_FILE) then
	fileObj = io.open(PORT_KEYS_FILE, "rb")
	keys_temp = json.decode(fileObj:read("*all"), 1, nil)
	fileObj:close()
	for key, value in pairs(keys_temp) do
	  if tonumber(key) then table.insert(keys, value)
	  else
	  keys[key]=value
	  end
    end
else
	keys = {}
	Note("fail!")
end


function set(key, value)
	keys[key] = value
	local orderedKeys = {}
	for k, v in ipairs(keys) do
		table.insert(orderedKeys, k)
	end
	table.sort(orderedKeys)
	for k, v in pairs(keys) do
    if type(keys[k]) == "string" then
       table.insert(orderedKeys, k)
	   end
	 end
	local fileObj = io.open(PORT_KEYS_FILE, "wb")
	fileObj:write(json.encode(keys, {indent=true, level=0, keyorder=orderedKeys}))
	fileObj:close()
end

function get(key)
	return keys[key]
end

function debug(...)
  args = {...}
  CallPlugin(DEBUG, "debug", ...)
end

function key_timer_set(key)
	key_timers[key] = os.time()
end

function key_timer_status(keytime)
		local current_time = os.time()
		local hours 		 = math.floor((current_time - keytime) / 3600)
		local hours_pretty   = hours   ~= 1 and "s" or ""
		local minutes 		 = math.floor((current_time - keytime) % 3600) / 60
		local minutes_pretty = minutes ~= 1 and "s" or ""
		local seconds 		 = math.floor((current_time - keytime) % 60)
		local seconds_pretty = seconds ~= 1 and "s" or ""
		return string.format("%d hour%s, %d minute%s, %d second%s.", hours, hours_pretty, minutes, minutes_pretty, seconds, seconds_pretty)
end
]]></script>

</muclient>
