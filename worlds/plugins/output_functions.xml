<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Tuesday, April 06, 2010, 8:39 AM -->
<!-- MuClient version 4.46 -->

<!-- Plugin "output_functions" generated by Plugin Wizard -->

<muclient>
<plugin
   name="output_functions"
   author="Oriol Gomez"
   id="54846c23d8b15594e7eb4b8a"
   language="Lua"
   purpose="provides functions to help tts users."
   date_written="2010-04-06 08:37:40"
   requires="4.46"
   version="1.1"
   >

</plugin>

<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Script  -->


<script>
<![CDATA[
require("mystdlib")

TTS = "925cdd0331023d9f0b8f05a7"
CONFIG = "d19a2f0a604c96b7318aa67f"

AcceleratorTo("ctrl + alt + enter", "interrupt_toggle()", sendto.script)
AcceleratorTo("ctrl + shift + space", "select_text()", sendto.script)

local return_code, keyboard_layout = CallPlugin(CONFIG, "get", "keyboard_layout")
if keyboard_layout == "dvorak" then
	AcceleratorTo("ctrl + shift + n", "next_line()", sendto.script)
	AcceleratorTo("ctrl + shift + t", "cur_line()", sendto.script)
	AcceleratorTo("ctrl + shift + h", "prev_line()", sendto.script)
	AcceleratorTo("ctrl + shift + s", "end_line()", sendto.script)
	AcceleratorTo("ctrl + shift + d", "top_line()", sendto.script)
else
	-- Default to qwerty.
	AcceleratorTo("ctrl + shift + l", "next_line()", sendto.script)
	AcceleratorTo("ctrl + shift + k", "cur_line()", sendto.script)
	AcceleratorTo("ctrl + shift + j", "prev_line()", sendto.script)
	AcceleratorTo("ctrl + shift + ;", "end_line()", sendto.script)
	AcceleratorTo("ctrl + shift + h", "top_line()", sendto.script)
end

AcceleratorTo("ctrl + shift + c", "copy_key()", sendto.script)

local return_code, interrupt = CallPlugin(CONFIG, "get", "interrupt_on_enter")
local last_count = 0
local current_line = 1
local selecting = false
local selection_start = 0

function buffer_lines_count()
	local count = GetLinesInBufferCount()
	if count < last_count then
		if current_line > 100 then
			current_line = current_line - 100
		else
			current_line = 1
		end
		if selecting then
			if selection_start > 100 then
				selection_start = selection_start - 100
			else
				selection_start = 1
			end
		end
	end
	last_count = count
	return count
end

function copy_key()
	local count = buffer_lines_count()
	if count <= 1 then
		CallPlugin(TTS, "say", "No output.", true)
		return
	elseif current_line == 0 then
		current_line = count
	end
	local line = GetLineInfo(current_line, 1) or ""
	local normal_key = line:match("^.+ key: '([a-z]+)'$")
	local identify_key = line:match("^Its magical key is ([a-z]+)[.]$")
	if normal_key then
		SetClipboard(normal_key)
		CallPlugin(TTS, "say", string.format("%s copied", normal_key), true)
	elseif identify_key then
		SetClipboard(identify_key)
		CallPlugin(TTS, "say", string.format("%s copied", identify_key), true)
	else
		CallPlugin(TTS, "say", "Key not found", true)
	end
end

function select_text()
	local count = buffer_lines_count()
	if count <= 1 then
		selecting = false
		CallPlugin(TTS, "say", "No output.", true)
		return
	elseif not selecting then
		selecting = true
		selection_start = current_line
		CallPlugin(TTS, "say", "selection start.", true)
	else
		local selected_text = {}
		local beginning = selection_start < current_line and selection_start or current_line
		local ending = current_line > selection_start and current_line or selection_start
		for i = beginning, ending do
			table.insert(selected_text, GetLineInfo(i, 1) or "")
		end
		SetClipboard(table.concat(selected_text, "\r\n"))
		selecting = false
		CallPlugin(TTS, "say", "Selection coppied.", true)
	end
end

function interrupt_toggle()
	interrupt = not interrupt
	CallPlugin(CONFIG, "set", "interrupt_on_enter", interrupt)
	Note(string.format("interrupt on enter %s.", interrupt and "on" or "off"))
end

function OnPluginCommandEntered(command)
	if interrupt then
		CallPlugin(TTS, "silence")
	end
end

function prev_line()
	local count = buffer_lines_count()
	if count <= 1 then
		CallPlugin(TTS, "say", "No output.", true)
		return
	elseif current_line - 1 <= 1 then
		CallPlugin(TTS, "say", "top", true)
	else
		current_line = current_line - 1
		local line = GetLineInfo(current_line, 1) or ""
		CallPlugin(TTS, "say", Trim(line) ~= "" and line or "blank", true)
	end
end

function cur_line()
	local count = buffer_lines_count()
	if count <= 1 then
		CallPlugin(TTS, "say", "No output.", true)
		return
	elseif current_line == 0 then
		current_line = count
	end
	local line = GetLineInfo(current_line, 1) or ""
	CallPlugin(TTS, "say", Trim(line) ~= "" and line or "blank", true)
end

function next_line()
	local count = buffer_lines_count()
	if count <= 1 then
		CallPlugin(TTS, "say", "No output.", true)
		return
	elseif current_line + 1 >= count then
		CallPlugin(TTS, "say", "bottom", true)
	else
		current_line = current_line + 1
		local line = GetLineInfo(current_line, 1) or ""
		CallPlugin(TTS, "say", Trim(line) ~= "" and line or "blank", true)
	end
end

function end_line()
	local count = buffer_lines_count()
	if count <= 1 then
		CallPlugin(TTS, "say", "No output.", true)
		return
	end
	current_line = count - 1
	local line = GetLineInfo(current_line, 1) or ""
	CallPlugin(TTS, "say", Trim(line) ~= "" and line or "blank", true)
end

function top_line()
	local count = buffer_lines_count()
	if count <= 1 then
		CallPlugin(TTS, "say", "No output.", true)
		return
	end
	current_line = 2
	local line = GetLineInfo(current_line, 1) or ""
	CallPlugin(TTS, "say", Trim(line) ~= "" and line or "blank", true)
end

]]>
</script>


</muclient>
