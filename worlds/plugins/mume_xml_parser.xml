<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- This Source Code Form is subject to the terms of the Mozilla Public -->
<!-- License, v. 2.0. If a copy of the MPL was not distributed with this -->
<!-- file, You can obtain one at http://mozilla.org/MPL/2.0/. -->

<!-- Saved on Wednesday, December 09, 2015, 6:22 PM -->
<!-- MuClient version 4.60 -->

<!-- Plugin "mume_xml_parser" generated by Plugin Wizard -->

<muclient>
<plugin
   name="mume_xml_parser"
   author="Nick Stockton"
   id="74834d3734b2c8a3a9da4d18"
   language="Lua"
   purpose="Parse Mume's XML output."
   date_written="2015-12-09 18:22:34"
   requires="4.60"
   version="1.0"
   >

</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>
<script>
<![CDATA[
require("mystdlib")

local IGNORE_BYTES = {["\0"] = true, ["\17"] = true}
local NEGOTIATION_BYTES = {["\254"] = true, ["\253"] = true, ["\252"] = true, ["\251"] = true}
local IAC = "\255"
local GA = "\249"
local IAC_GA = IAC .. GA
local SB = "\250"
local SE = "\240"
local ESC = "\27"
local XML_NONE = 0
local XML_ROOM = 2
local XML_NAME = 4
local XML_DESCRIPTION = 8
local XML_EXITS = 16
local XML_PROMPT = 32
local XML_TERRAIN = 64
local XML_REPLACEMENTS = {
	["&lt;"] = "<",
	["&gt;"] = ">",
	["&amp;"] = "&",
	["&#39;"] = "'",
	["&apos;"] = "'",
	["&quot;"] = '"',
}
local TAG_REPLACEMENTS = {
	["tell"] = "TELL:",
	["/tell"] = ":TELL",
	["narrate"] = "NARRATE:",
	["/narrate"] = ":NARRATE",
	["pray"] = "PRAY:",
	["/pray"] = ":PRAY",
	["say"] = "SAY:",
	["/say"] = ":SAY",
	["emote"] = "EMOTE:",
	["/emote"] = ":EMOTE",
}

local in_esc = false
local in_iac = false
local in_sub_option = false
local xml_mode = XML_NONE
local last_data = {name="", description="", dynamic="", exits="", prompt=""}
local scouting = false
local reading_tag = false
local initial_packet = true
local last_packet = ""

function get(key)
	return last_data[key]
end

function process_text(data)
	if data == "" then
		return ""
	end
	data = string.gsub(tostring(data), "&[^; ]+;", function(str) return XML_REPLACEMENTS[str] or str end)
	if xml_mode == XML_NONE and data:findpos("You quietly scout ") then
		scouting = true
	elseif xml_mode == XML_ROOM then
		-- dynamic description
		last_data["dynamic"] = string.format("%s%s\n", last_data["dynamic"], data)
	elseif xml_mode == XML_NAME then
		last_data["name"] = string.format("%s%s", last_data["name"], data)
	elseif xml_mode == XML_DESCRIPTION then
		last_data["description"] = string.format("%s%s\n", last_data["description"], data)
	elseif xml_mode == XML_EXITS then
		last_data["exits"] = string.format("%s%s", last_data["exits"], data)
	elseif xml_mode == XML_PROMPT then
		last_data["prompt"] = string.format("%s%s", last_data["prompt"], data)
		return ""
	end
	return data
end

function OnPluginPacketReceived(packet)
	last_packet = last_packet .. packet
	if initial_packet then
		-- This exception is necessary for displaying the log-in screen before the player types an account/character name.
		if last_packet:findpos("By what name do you wish to be known?") then
			last_packet = ""
			initial_packet = nil
		end
		return packet .. IAC_GA
	elseif last_packet:findpos(IAC_GA) then
		-- Split the data on the last IAC-GA sequence (I.E. the Mume prompt) in case of data being broken over multiple packets.
		packet, last_packet = last_packet:match(string.format("(.*%s)(.*)", IAC_GA))
	elseif last_packet:findpos("\n") then
		-- This is needed for instances in which Mume doesn't immediately return a prompt after command output, such as when a player attempts to backstab.
		packet, last_packet = last_packet:match("(.*\n)(.*)")
	else
		-- Data is definitely been broken up over multiple packets.
		-- Return nothing and continue buffering until complete data has been received.
		return ""
	end
	local character_buffer = {}
	local tag_buffer = {}
	local result = {}
	for byte in packet:gmatch(".") do
		if not in_sub_option and (not in_iac and not IGNORE_BYTES[byte] or in_iac and byte == IAC) then
			-- Byte is *not* part of a Telnet sequence.
			if byte == IAC then
				-- Escaped IAC.
				in_iac = false
			end
			if byte == ESC then
				-- Beginning Ansi escape code.
				table.insert(result, byte)
				in_esc = true
			elseif in_esc then
				-- Byte is part of an Ansi escape code.
				table.insert(result, byte)
				if not string.match(byte, "[%d[;]") then
					-- Byte is the final byte in an Ansi escape code.
					in_esc = false
				end
			elseif not reading_tag then
				-- Byte is out side of a tag, or in between opening and closing tags.
				if byte ~= "<" then
					-- Add the byte to the character buffer.
					table.insert(character_buffer, byte)
				else
					-- Start of tag.
					-- Process the bytes in the character buffer, and write them to the result buffer.
					table.insert(result, process_text(table.concat(character_buffer)))
					character_buffer = {}
					reading_tag = true
				end
			elseif byte ~= ">" then
				-- A tag is being parsed, and the end of the tag has *not* been reached yet.
				table.insert(tag_buffer, byte)
			else
				-- End of XML tag.
				local tag = table.concat(tag_buffer)
				if xml_mode == XML_NONE then
					if tag == "/xml" then
						-- XML mode was turned off by the player.
						xml_mode = XML_NONE
					elseif TAG_REPLACEMENTS[tag] then
						-- Replace the tag with a marked up version for triggering.
						table.insert(result, TAG_REPLACEMENTS[tag])
					elseif tag == "prompt" then
						last_data.prompt = ""
						xml_mode = XML_PROMPT
					elseif scouting then
						-- The next incoming room data should be ignored. For example if the player is scouting.
					elseif tag == "exits" then
						xml_mode = XML_EXITS
					elseif tag == "room" then
						last_data = {name="", description="", dynamic="", exits=""}
						xml_mode = XML_ROOM
					elseif string.startswith(tag, "movement") then
						BroadcastPlugin(2, string.match(tag, "^movement dir=(%w+)/$") or "")
						scouting = false
					elseif tag == "status" then
						xml_mode = XML_NONE
					end
				elseif xml_mode == XML_ROOM then
					if tag == "name" then
						xml_mode = XML_NAME
					elseif tag == "description" then
						xml_mode = XML_DESCRIPTION
					elseif tag == "terrain" then
						xml_mode = XML_TERRAIN
					elseif tag == "/room" then
						xml_mode = XML_NONE
					end
				elseif (xml_mode == XML_NAME and tag == "/name") or (xml_mode == XML_DESCRIPTION and tag == "/description") or (xml_mode == XML_TERRAIN and tag == "/terrain") then
					xml_mode = XML_ROOM
				elseif xml_mode == XML_EXITS and tag == "/exits" then
					xml_mode = XML_NONE
				elseif xml_mode == XML_PROMPT and tag == "/prompt" then
					BroadcastPlugin(1, "")
					scouting = false
					xml_mode = XML_NONE
				end
				tag_buffer = {}
				reading_tag = false
			end
		elseif not in_iac then
			-- Byte is IAC, ignored, or part of a sub-negotiation.
			table.insert(result, byte)
			if byte == IAC then
				-- unescaped IAC, start of Telnet negotiation.
				in_iac = true
			end
		else
			-- Telnet negotiation
			table.insert(result, byte)
			if not NEGOTIATION_BYTES[byte] then
				-- Byte is the last byte in the negotiation sequence.
				in_iac = false
				if byte == SB then
					-- Begin sub-negotiation.
					in_sub_option = true
				elseif byte == SE then
					-- End sub-negotiation
					in_sub_option = false
				end
			end
		end -- else
	end -- for
	if not reading_tag then
		table.insert(result, process_text(table.concat(character_buffer)))
	end
	return table.concat(result)
end

]]>            
 </script> 
</muclient>
