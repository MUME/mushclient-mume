<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- This Source Code Form is subject to the terms of the Mozilla Public -->
<!-- License, v. 2.0. If a copy of the MPL was not distributed with this -->
<!-- file, You can obtain one at http://mozilla.org/MPL/2.0/. -->

<!-- Saved on Wednesday, December 09, 2015, 6:22 PM -->
<!-- MuClient version 4.60 -->

<!-- Plugin "mume_xml_parser" generated by Plugin Wizard -->

<muclient>
<plugin
   name="mume_xml_parser"
   author="Nick Stockton"
   id="74834d3734b2c8a3a9da4d18"
   language="Lua"
   purpose="Parse Mume's XML output."
   date_written="2015-12-09 18:22:34"
   requires="4.60"
   version="1.0"
   >

</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>
<!--  Aliases  -->

<aliases>
  <alias
   name="show_prompt"
   match="showprompt"
   enabled="y"
   group="mume_xml_parser"
   send_to="12"
   sequence="100"
  >
  <send>toggle_show_prompt()</send>
  </alias>
</aliases>

<script>
<![CDATA[
require("mystdlib")
CONFIG = "d19a2f0a604c96b7318aa67f"

local DELIMITER_REGEX = rex.new([[^(?P<complete>.*(?:[\n]|[\xff][\xfb\xfc\xfd\xfe]?.{1,1}))(?P<incomplete>.*)$]], rex.flags().DOTALL)
local LOGIN_PROMPT = "By what name do you wish to be known?"
local IGNORE_BYTES = {["\0"] = true, ["\17"] = true}
local NEGOTIATION_BYTES = {["\254"] = true, ["\253"] = true, ["\252"] = true, ["\251"] = true}
local IAC = "\255"
local GA = "\249"
local IAC_GA = IAC .. GA
local SB = "\250"
local SE = "\240"
local XML_NONE = 0
local XML_ROOM = 2
local XML_NAME = 4
local XML_DESCRIPTION = 8
local XML_EXITS = 16
local XML_PROMPT = 32
local XML_TERRAIN = 64
local XML_TELL = 128
local XML_NARRATE = 256
local XML_PRAY = 512
local XML_SAY = 1024
local XML_EMOTE = 2048
local XML_REPLACEMENTS = {
	["&amp;"] = "&",
	["&lt;"] = "<",
	["&gt;"] = ">",
	["&#39;"] = "'",
	["&apos;"] = "'",
	["&quot;"] = '"',
}
local BROADCAST_PROMPT = 1
local BROADCAST_MOVEMENT = 2
local BROADCAST_EXITS = 3
local BROADCAST_NAME = 4
local BROADCAST_TELL = 5
local BROADCAST_NARRATE = 6
local BROADCAST_PRAY = 7
local BROADCAST_SAY = 8
local BROADCAST_EMOTE = 9

local text_buffer = {}
local tag_buffer = {}
local in_iac = false
local in_sub_option = false
local in_gratuitous = false
local xml_mode = XML_NONE
local last_data = {name="", description="", dynamic="", exits="", prompt=""}
local scouting = false
local reading_tag = false
local initial_packet = true
local last_packet = ""
local return_code, show_prompt = CallPlugin(CONFIG, "get", "show_prompt")
local last_communication = ""

function get(key)
	return StripANSI(last_data[key])
end

function toggle_show_prompt()
	show_prompt = not show_prompt
	CallPlugin(CONFIG, "set", "show_prompt", show_prompt)
	Note("Show prompt ", show_prompt and "on" or "off", ".")
end

function process_text(data)
	if data == "" then
		return ""
	end
	data = string.gsub(data, "&[^; ]+;", XML_REPLACEMENTS)
	if xml_mode == XML_NONE and data:findpos("You quietly scout ") then
		scouting = true
	elseif xml_mode == XML_PROMPT then
		last_data.prompt = last_data.prompt .. data
		if not show_prompt then
			return ""
		end
	elseif xml_mode >= XML_TELL and xml_mode <= XML_EMOTE then
		last_communication = last_communication .. data
	elseif scouting then
		-- The next incoming room data should be ignored. For example if the player is scouting.
	elseif xml_mode == XML_ROOM then
		-- dynamic description
		last_data.dynamic = string.format("%s%s\n", last_data.dynamic, data)
	elseif xml_mode == XML_NAME then
		last_data.name = last_data.name .. data
	elseif xml_mode == XML_DESCRIPTION then
		last_data.description = string.format("%s%s\n", last_data.description, data)
	elseif xml_mode == XML_EXITS then
		last_data.exits = last_data.exits .. data
	end
	if in_gratuitous then
		return ""
	end
	return data
end

function process_tag(tag)
	if xml_mode == XML_NONE then
		if tag == "/xml" then
			-- XML mode was turned off by the player.
			xml_mode = XML_NONE
		elseif tag == "tell" then
			xml_mode = XML_TELL
		elseif tag == "narrate" then
			xml_mode = XML_NARRATE
		elseif tag == "pray" then
			xml_mode = XML_PRAY
		elseif tag == "say" then
			xml_mode = XML_SAY
		elseif tag == "emote" then
			xml_mode = XML_EMOTE
		elseif tag == "prompt" then
			scouting = false
			last_data.prompt = ""
			xml_mode = XML_PROMPT
		elseif tag == "exits" then
			xml_mode = XML_EXITS
		elseif tag == "room" then
			if not scouting then
				last_data.name = ""
				last_data.description = ""
				last_data.dynamic = ""
				last_data.exits = ""
			end
			xml_mode = XML_ROOM
		elseif string.startswith(tag, "movement") then
			scouting = false
			BroadcastPlugin(BROADCAST_MOVEMENT, string.match(tag, "^movement dir=(%w+)/$") or "")
		elseif tag == "status" then
			xml_mode = XML_NONE
		end
	elseif xml_mode == XML_ROOM then
		if tag == "name" then
			xml_mode = XML_NAME
		elseif tag == "description" then
			xml_mode = XML_DESCRIPTION
		elseif tag == "terrain" then
			xml_mode = XML_TERRAIN
		elseif tag == "gratuitous" then
			in_gratuitous = true
		elseif tag == "/gratuitous" then
			in_gratuitous = false
		elseif tag == "/room" then
			xml_mode = XML_NONE
		end
	elseif (xml_mode == XML_DESCRIPTION and tag == "/description") or (xml_mode == XML_TERRAIN and tag == "/terrain") then
		xml_mode = XML_ROOM
	elseif xml_mode == XML_NAME and tag == "/name" then
		xml_mode = XML_ROOM
		BroadcastPlugin(BROADCAST_NAME, StripANSI(last_data.name))
	elseif xml_mode == XML_EXITS and tag == "/exits" then
		xml_mode = XML_NONE
		BroadcastPlugin(BROADCAST_EXITS, StripANSI(last_data.exits))
	elseif xml_mode == XML_TELL and tag == "/tell" then
		xml_mode = XML_NONE
		BroadcastPlugin(BROADCAST_TELL, StripANSI(last_communication))
		last_communication = ""
	elseif xml_mode == XML_NARRATE and tag == "/narrate" then
		xml_mode = XML_NONE
		BroadcastPlugin(BROADCAST_NARRATE, StripANSI(last_communication))
		last_communication = ""
	elseif xml_mode == XML_PRAY and tag == "/pray" then
		xml_mode = XML_NONE
		BroadcastPlugin(BROADCAST_PRAY, StripANSI(last_communication))
		last_communication = ""
	elseif xml_mode == XML_SAY and tag == "/say" then
		xml_mode = XML_NONE
		BroadcastPlugin(BROADCAST_SAY, StripANSI(last_communication))
		last_communication = ""
	elseif xml_mode == XML_EMOTE and tag == "/emote" then
		xml_mode = XML_NONE
		BroadcastPlugin(BROADCAST_EMOTE, StripANSI(last_communication))
		last_communication = ""
	elseif xml_mode == XML_PROMPT and tag == "/prompt" then
		xml_mode = XML_NONE
		BroadcastPlugin(BROADCAST_PROMPT, StripANSI(last_data.prompt))
	end
end

function OnPluginPacketReceived(packet)
	if initial_packet and string.findpos(packet, LOGIN_PROMPT) then
		-- Mume does not send IAC + GA or a new line character after the login prompt, even when it is told to put IAC + GA and end of prompts.
		packet = packet .. "\r\n"
		initial_packet = false
	end
	last_packet = last_packet .. packet
	local starting, ending, match = DELIMITER_REGEX:match(last_packet)
	if match then
		-- Data has been split over multiple packets. Handle the complete data, and add the incomplete date to the buffer.
		packet = string.gsub(match["complete"], IAC_GA, "\r\n")
		last_packet = match["incomplete"]
	else
		-- Return nothing and continue buffering until complete data has been received.
		return ""
	end
	local result = {}
	for byte in packet:gmatch(".") do
		if in_iac and byte ~= IAC then
			-- Telnet negotiation
			--if not NEGOTIATION_BYTES[byte] or NEGOTIATION_BYTES[result[table.getn(result)]] then
			if not NEGOTIATION_BYTES[byte] then
				-- Byte is the last byte in a negotiation sequence.
				in_iac = false
			end
			if byte == SB then
				-- Begin sub-negotiation.
				in_sub_option = true
			elseif byte == SE then
				-- End sub-negotiation
				in_sub_option = false
			end
			table.insert(result, byte)
		elseif not in_iac and byte == IAC then
			-- unescaped IAC, start of Telnet negotiation.
			in_iac = true
			table.insert(result, byte)
		elseif in_sub_option or IGNORE_BYTES[byte] then
			-- Pass these through.
			table.insert(result, byte)
		elseif byte == ">" and reading_tag then
			-- End of XML tag.
			process_tag(table.concat(tag_buffer))
			table.clear(tag_buffer)
			reading_tag = false
		elseif reading_tag then
			-- A tag is being parsed, and the end of the tag has *not* been reached yet.
			in_iac = false
			table.insert(tag_buffer, byte)
		elseif byte == "<" then
			-- Start of tag.
			-- Process the bytes in the character buffer, and write them to the result buffer.
			table.insert(result, process_text(table.concat(text_buffer)))
			table.clear(text_buffer)
			reading_tag = true
		else
			-- Byte is out side of a tag, or in between opening and closing tags.
			in_iac = false
			table.insert(text_buffer, byte)
		end
	end -- for
	if not reading_tag and not table.isempty(text_buffer) then
		table.insert(result, process_text(table.concat(text_buffer)))
		table.clear(text_buffer)
	end
	return table.concat(result)
end

]]>            
 </script> 
</muclient>
