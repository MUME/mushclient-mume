<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- This Source Code Form is subject to the terms of the Mozilla Public -->
<!-- License, v. 2.0. If a copy of the MPL was not distributed with this -->
<!-- file, You can obtain one at http://mozilla.org/MPL/2.0/. -->

<!-- Saved on Sunday, February 19, 2012, 4:49 AM -->
<!-- MuClient version 4.81 -->

<!-- Plugin "mume_time" generated by Plugin Wizard -->

<muclient>
<plugin
   name="mume_time"
   author="Nick Stockton"
   id="9fdc018bc023962f72f2439d"
   language="Lua"
   purpose="Keeps track of the time in MUME."
   date_written="2012-02-19 04:48:01"
   requires="4.70"
   version="1.0"
   >

</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Triggers  -->

<triggers>
  <trigger
   enabled="y"
   group="mume_time"
   match="^(?:It seems as if )?[Tt]he day has begun\.(?: You feel so weak under the cruel light\!)?$"
   name="sync_event1"
   send_to="12"
   regexp="y"
   sequence="100"
  >
  <send>
if not synchronized and time_event == "" then
	time_event = "dawn"
	time_event_offset = 1
	Send("time")
end
  </send>
  </trigger>
  <trigger
   enabled="y"
   group="mume_time"
   match="^Light gradually filters in\, proclaiming a new sunrise(?: outside)?\.$"
   name="sync_event2"
   send_to="12"
   regexp="y"
   sequence="100"
  >
  <send>
if not synchronized and time_event == "" then
	time_event = "dawn"
	time_event_offset = 0
	Send("time")
end
  </send>
  </trigger>
  <trigger
   enabled="y"
   group="mume_time"
   match="^(?:It seems as if )?[Tt]he night has begun\.(?: You feel stronger in the dark\!)?$"
   name="sync_event3"
   send_to="12"
   regexp="y"
   sequence="100"
  >
  <send>
if not synchronized and time_event == "" then
	time_event = "dusk"
	time_event_offset = 1
	Send("time")
end
  </send>
  </trigger>
  <trigger
   enabled="y"
   group="mume_time"
   match="The last ray of light fades, and all is swallowed up in darkness."
   name="sync_event4"
   send_to="12"
   sequence="100"
  >
  <send>
if not synchronized and time_event == "" then
	time_event = "dusk"
	time_event_offset = 1
	Send("time")
end
  </send>
  </trigger>
  <trigger
   enabled="y"
   group="mume_time"
   match="^The deepening gloom announces another sunset(?: outside)?\.$"
   name="sync_event5"
   send_to="12"
   regexp="y"
   sequence="100"
  >
  <send>
if not synchronized and time_event == "" then
	time_event = "dusk"
	time_event_offset = 0
	Send("time")
end
  </send>
  </trigger>
  <trigger
   enabled="y"
   group="mume_time"
   match="^The current time is (?P&lt;hour&gt;[1-9]|1[0-2])\:(?P&lt;minutes&gt;[0-5]\d)(?P&lt;am_pm&gt;[ap]m)\.$"
   name="sync_from_clock"
   omit_from_output="y"
   send_to="14"
   regexp="y"
   sequence="100"
  >
  <send>
if not synchronized and time_event == "" then
	-- parsed_hour should be 0 - 23.
	parsed_hour = tonumber("%&lt;hour&gt;") % 12 + ("%&lt;am_pm&gt;" == "pm" and 12 or 0)
	parsed_minutes = tonumber("%&lt;minutes&gt;")
	if parsed_hour == 23 and parsed_minutes == 59 then
		AddTimer("send_look_clock", 0, 0, 1, "look at clock", timer_flag.Enabled + timer_flag.OneShot + timer_flag.ActiveWhenClosed + timer_flag.Replace + timer_flag.Temporary, "")
		SetTimerOption("send_look_clock", "send_to", sendto.world)
	else
		time_event = "clock"
		Note("%0")
		Send("time")
	end
else
	Note("%0")
end
  </send>
  </trigger>
  <trigger
   enabled="y"
   group="mume_time"
   match="^(?:(?:It is )?(?P&lt;hour&gt;[1-9]|1[0-2])(?P&lt;am_pm&gt;[ap]m)(?: on ))?\w+\, the (?P&lt;day&gt;\d+)(?:st|[nr]d|th) of (?P<month>\w+)\, [yY]ear (?P&lt;year&gt;\d{4}) of the Third Age\.$"
   name="parse_time"
   omit_from_output="y"
   send_to="14"
   regexp="y"
   sequence="100"
  >
  <send>
if not synchronized and time_event ~= "" then
	local month = 1
	local day = tonumber("%&lt;day&gt;")
	local year = tonumber("%&lt;year&gt;")
	for i, m in ipairs(MONTHS) do
		if m.westron == "%&lt;month&gt;" or m.sindarin == "%&lt;month&gt;" then
			month = i
			break
		end
	end
	if time_event == "dawn" or time_event == "dusk" then
		parsed_hour = MONTHS[month][time_event] + time_event_offset
		parsed_minutes = 0
	end
	MUME_EPOCH = time_to_epoch(year, month, day, parsed_hour, parsed_minutes)
	CallPlugin(CONFIG, "set", "mume_epoch", MUME_EPOCH)
	time_event = ""
	time_event_offset = 0
	synchronized = true
	Note(string.format("%0 (Synchronized with epoch %d)", MUME_EPOCH))
else
	Note("%0")
end
  </send>
  </trigger>
  <trigger
   enabled="y"
   group="mume_time"
   match="A huge clock is standing here."
   name="look_at_clock"
   send_to="12"
   sequence="100"
  >
  <send>
if not synchronized and time_event == "" then
	Send("look at clock")
end
  </send>
  </trigger>
</triggers>

<!--  Aliases  -->

<aliases>
  <alias
   match="pulldate"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  <send>time_check("pull")</send>
  </alias>
  <alias
   match="ti"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  <send>time_check()</send>
  </alias>
  <alias
   match="nti"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  <send>time_check("narrate")</send>
  </alias>
  <alias
   match="sti"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  <send>time_check("say")</send>
  </alias>
</aliases>

<!--  Script  -->


<script>
<![CDATA[
CONFIG = "d19a2f0a604c96b7318aa67f"

return_code, MUME_EPOCH = CallPlugin(CONFIG, "get", "mume_epoch")
if not MUME_EPOCH then
	MUME_EPOCH = 1517486463
end
FIRST_YEAR = 2850

MINUTES_PER_HOUR = 60
HOURS_PER_DAY = 24
DAYS_PER_MONTH = 30
MONTHS_PER_YEAR = 12
DAYS_PER_YEAR = DAYS_PER_MONTH * MONTHS_PER_YEAR
MINUTES_PER_DAY = MINUTES_PER_HOUR * HOURS_PER_DAY
MINUTES_PER_MONTH = MINUTES_PER_DAY * DAYS_PER_MONTH
MINUTES_PER_YEAR = MINUTES_PER_DAY * DAYS_PER_YEAR

MONTHS = {
	{["name"] = "January", ["sindarin"] = "Ninui", ["westron"] = "Solmath", ["dawn"] = 9, ["dusk"] = 17, ["season"] = "Winter"},
	{["name"] = "February", ["sindarin"] = "Gwaeron", ["westron"] = "Rethe", ["dawn"] = 8, ["dusk"] = 18, ["season"] = "Late-Winter"},
	{["name"] = "March", ["sindarin"] = "Gwirith", ["westron"] = "Astron", ["dawn"] = 7, ["dusk"] = 19, ["season"] = "Early-Spring"},
	{["name"] = "April", ["sindarin"] = "Lothron", ["westron"] = "Thrimidge", ["dawn"] = 7, ["dusk"] = 20, ["season"] = "Spring"},
	{["name"] = "May", ["sindarin"] = "Norui", ["westron"] = "Forelithe", ["dawn"] = 6, ["dusk"] = 20, ["season"] = "Late-Spring"},
	{["name"] = "June", ["sindarin"] = "Cerveth", ["westron"] = "Afterlithe", ["dawn"] = 5, ["dusk"] = 21, ["season"] = "Early-Summer"},
	{["name"] = "July", ["sindarin"] = "Urui", ["westron"] = "Wedmath", ["dawn"] = 4, ["dusk"] = 22, ["season"] = "Summer"},
	{["name"] = "August", ["sindarin"] = "Ivanneth", ["westron"] = "Halimath", ["dawn"] = 5, ["dusk"] = 21, ["season"] = "Late-Summer"},
	{["name"] = "September", ["sindarin"] = "Narbeleth", ["westron"] = "Winterfilth", ["dawn"] = 6, ["dusk"] = 20, ["season"] = "Early-Autumn"},
	{["name"] = "October", ["sindarin"] = "Hithui", ["westron"] = "Blotmath", ["dawn"] = 7, ["dusk"] = 20, ["season"] = "Autumn"},
	{["name"] = "November", ["sindarin"] = "Girithron", ["westron"] = "Foreyule", ["dawn"] = 7, ["dusk"] = 19, ["season"] = "Late-Autumn"},
	{["name"] = "December", ["sindarin"] = "Narwain", ["westron"] = "Afteryule", ["dawn"] = 8, ["dusk"] = 18, ["season"] = "Early-Winter"}
}

WEEKDAYS = {
	{["name"] = "Sunday", ["sindarin"] = "Oranor", ["westron"] = "Sunday"},
	{["name"] = "Monday", ["sindarin"] = "Orithil", ["westron"] = "Monday"},
	{["name"] = "Tuesday", ["sindarin"] = "Orgaladhad", ["westron"] = "Trewsday"},
	{["name"] = "Wednesday", ["sindarin"] = "Ormenel", ["westron"] = "Hevensday"},
	{["name"] = "Thursday", ["sindarin"] = "Orbelain", ["westron"] = "Mersday"},
	{["name"] = "Friday", ["sindarin"] = "Oraearon", ["westron"] = "Highday"},
	{["name"] = "Saturday", ["sindarin"] = "Orgilion", ["westron"] = "Sterday"}
}

time_event = ""
time_event_offset = 0
synchronized = false
parsed_hour = 0
parsed_minutes = 0

function time_to_epoch(year, month, day, hour, minutes)
	return os.time() - ((year - FIRST_YEAR) * MINUTES_PER_YEAR) - ((month - 1) * MINUTES_PER_MONTH) - ((day - 1) * MINUTES_PER_DAY) - (hour * MINUTES_PER_HOUR) - minutes
end

function time_check(action)
	local minutes = os.time() - MUME_EPOCH
	local year = math.floor(minutes / MINUTES_PER_YEAR) + FIRST_YEAR
	minutes = minutes % MINUTES_PER_YEAR
	local month = math.floor(minutes / MINUTES_PER_MONTH) + 1
	minutes = minutes % MINUTES_PER_MONTH
	local day = math.floor(minutes / MINUTES_PER_DAY) + 1
	minutes = minutes % MINUTES_PER_DAY
	local day_of_year = (month - 1) * DAYS_PER_MONTH + day
	local hour = math.floor(minutes / MINUTES_PER_HOUR)
	minutes = minutes % MINUTES_PER_HOUR
	local ap = hour < 12 and "am" or "pm"
	if action and action == "pull" then
		Send("pull lever ", day)
		Send("pull lever ", MONTHS[month].westron)
		return
	end
	output = string.format("Game time %d:%s%d %s: Dawn: %d am, Dusk: %d pm.", hour % 12 ~= 0 and hour % 12 or 12, minutes < 10 and "0" or "", minutes, ap, MONTHS[month].dawn, MONTHS[month].dusk - 12)
	if action then
		return Send(action, " ", output)
	else
		Note(output)
	end
	local weekday = WEEKDAYS[(day_of_year + (year - FIRST_YEAR) * DAYS_PER_YEAR) % 7 + 1].name
	local state = ""
	local next_state = ""
	local till_next_state = 0
	if hour < MONTHS[month].dawn then
		state = "NIGHT"
		next_state = "DAY"
		till_next_state = MONTHS[month].dawn - hour + 1
	elseif hour >= MONTHS[month].dusk then
		state = "NIGHT"
		next_state = "DAY"
		till_next_state = 25 + MONTHS[month].dawn - hour
	elseif hour > MONTHS[month].dawn and hour < MONTHS[month].dusk then
		state = "DAY"
		next_state = "NIGHT"
		till_next_state = MONTHS[month].dusk - hour
	elseif hour == MONTHS[month].dawn then
		state = "DAWN"
		next_state = "DAY"
		till_next_state = 1
	end
	Note(string.format("It is currently %s, on %s, %s %d (%s / %s), (%s), year %d of the third age.", state, weekday, MONTHS[month].name, day, MONTHS[month].westron, MONTHS[month].sindarin, MONTHS[month].season, year))
	Note(string.format("Time left until %s is less than %d tick%s", next_state, till_next_state, till_next_state ~= 1 and "s" or "!"))
	local next_season_in_mume_days = (((math.floor(month / 3) * 3 + 3) - month - 1) * DAYS_PER_MONTH) + (DAYS_PER_MONTH - day) + (1 - math.floor(hour / HOURS_PER_DAY))
	local next_season_in_rl_hours = math.floor(next_season_in_mume_days * HOURS_PER_DAY / MINUTES_PER_HOUR)
	Note(string.format("%s ends in %d mume day%s or %d real-life hour%s.", string.sub(MONTHS[month].season, -6), next_season_in_mume_days, next_season_in_mume_days ~= 1 and "s" or "", next_season_in_rl_hours, next_season_in_rl_hours ~= 1 and "s" or ""))
	local next_winter_in_mume_days = ((MONTHS_PER_YEAR - month % 12 - 1) * DAYS_PER_MONTH) + (DAYS_PER_MONTH - day) + (1 - math.floor(hour / HOURS_PER_DAY))
	local next_winter_in_rl_days = math.floor(math.floor(next_winter_in_mume_days * HOURS_PER_DAY / MINUTES_PER_HOUR) / HOURS_PER_DAY)
	local next_winter_in_rl_hours = math.floor(next_winter_in_mume_days * HOURS_PER_DAY / MINUTES_PER_HOUR) % HOURS_PER_DAY
	Note(string.format("Next winter starts in %d real-life day%s and %d hour%s.", next_winter_in_rl_days, next_winter_in_rl_days ~= 1 and "s" or "", next_winter_in_rl_hours, next_winter_in_rl_hours ~= 1 and "s" or ""))
	local moon_rise = (day_of_year - 1) % 24
	local moon_rise_day = ""
	local moon_rise_ap = ""
	if hour == moon_rise then
		Note("Moon is up now!")
	else
		if hour > moon_rise then
			moon_rise = day_of_year % 24
			moon_rise_day = "tomorrow"
		else
			moon_rise_day = "today"
		end
		moon_rise_ap = moon_rise < 12 and "am" or "pm"
		Note(string.format("Next moon rise %s at %d:00 %s (game time).", moon_rise_day, moon_rise % 12 ~= 0 and moon_rise % 12 or 12, moon_rise_ap))
	end
	local full_moon_cycle = HOURS_PER_DAY * 24 -- Every 24 days
	local moon_day = (day_of_year + DAYS_PER_MONTH + 24) % 24
	local moon_hour = moon_day * 24 + hour % HOURS_PER_DAY
	local next_dk_day = 1
	local ticks_until_dk = 0
	if moon_hour < 20 then
		ticks_until_dk = moon_hour <= 17 and 17 - moon_hour or 0
	elseif moon_hour < HOURS_PER_DAY + 21 then
		ticks_until_dk = moon_hour <= HOURS_PER_DAY + 18 and HOURS_PER_DAY + 18 - moon_hour or 0
		next_dk_day = 2
	elseif moon_hour < HOURS_PER_DAY * 2 + 22 then
		ticks_until_dk = moon_hour <= HOURS_PER_DAY * 2 + 19 and HOURS_PER_DAY * 2 + 19 - moon_hour or 0
		next_dk_day = 3
	else
		ticks_until_dk = full_moon_cycle - moon_hour + 17
	end
	local next_dk_in_rl_hours = math.floor(ticks_until_dk / MINUTES_PER_HOUR)
	local next_dk_in_rl_minutes = ticks_until_dk % MINUTES_PER_HOUR
	if ticks_until_dk == 0 then
		Note("DK is open now!")
	else
		Note(string.format("DK opens in %d real-life hour%s and %d minute%s (day %d of 3).", next_dk_in_rl_hours, next_dk_in_rl_hours ~= 1 and "s" or "", next_dk_in_rl_minutes, next_dk_in_rl_minutes ~= 1 and "s" or "", next_dk_day))
	end
end

]]>
</script>


</muclient>
